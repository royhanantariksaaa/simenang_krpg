<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activity Diagram Generator v5</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/dracula.min.css">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: none; width: 95%; margin: 0 auto; background: white; border-radius: 15px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; min-width: 1000px; }
        .header { background: linear-gradient(135deg, #0070c0 0%, #005a9c 100%); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; font-weight: 300; }
        .header p { font-size: 1.1em; opacity: 0.9; }
        .main-content { display: flex; min-height: 600px; }
        .input-panel { flex: 0 0 400px; padding: 30px; border-right: 1px solid #e0e0e0; background: #fafafa; }
        .output-panel { flex: 1; padding: 30px; background: white; overflow-x: auto; min-width: 600px; }
        .CodeMirror { height: 400px; border-radius: 8px; border: 2px solid #e0e0e0; font-size: 14px; }
        .button-group { display: flex; gap: 15px; margin-top: 20px; justify-content: center; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.5px; }
        .btn-primary { background: linear-gradient(135deg, #0070c0 0%, #005a9c 100%); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(0,112,192,0.3); }
        .btn-secondary { background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%); color: white; }
        .btn-secondary:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(108,117,125,0.3); }
        .btn-success { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; }
        .btn-success:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(40,167,69,0.3); }
        .swimlanes-container { position: relative; border: 2px solid #333; margin-top: 20px; background: #fff; border-radius: 8px; overflow-x: auto; min-height: 500px; }
        .swimlane { position: absolute; top: 0; height: 100%; border-right: 2px solid #ccc; box-sizing: border-box; background-color: #f8f9fa; }
        .swimlane:nth-child(even) { background-color: #fff; }
        .swimlane:last-child { border-right: none; }
        .swimlane-title { text-align: center; font-weight: bold; padding: 15px; border-bottom: 2px solid #ccc; background: #e9ecef; color: #333; font-size: 1.1em; position: sticky; top: 0; z-index: 10; }
        .diagram-container { background: white; border-radius: 8px; padding: 20px; min-height: 500px; border: 2px solid #e0e0e0; }
        .diagram-title { text-align: center; font-size: 1.8em; font-weight: bold; color: #0070c0; margin-bottom: 30px; padding: 15px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; }
        .node { position: absolute; transform: translate(-50%, -50%); z-index: 5; box-shadow: 0 3px 10px rgba(0,0,0,0.2); border-radius: 8px; font-size: 14px; font-weight: 500; text-align: center; padding: 12px 16px; word-wrap: break-word; }
        .node-activity { background: linear-gradient(135deg, #7fbcff 0%, #5a9cff 100%); border: 2px solid #0070c0; color: #1a1a1a; }
        .node-start { background: #333; border: 3px solid #333; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .node-end { background: white; border: 3px solid #333; color: #333; width: 46px; height: 46px; border-radius: 50%; display: flex; align-items: center; justify-content: center; position: relative; }
        .node-end::after { content: ''; width: 32px; height: 32px; background: #333; border-radius: 50%; }
        .node-decision { background: linear-gradient(135deg, #fce5a7 0%, #f7d06e 100%); border: 2px solid #c69500; color: #333; width: 80px; height: 80px; transform: translate(-50%, -50%) rotate(45deg); }
        .node-decision-text { height: 100%; width: 100%; display: flex; align-items: center; justify-content: center; transform: rotate(-45deg); word-break: break-word; padding: 5px; }
        .node-datastore { background: linear-gradient(135deg, #a9dcfc 0%, #87ceeb 100%); border: 2px solid #0070c0; color: #1a1a1a; }
        .node-merge { background: linear-gradient(135deg, #7fbcff 0%, #5a9cff 100%); border: 2px solid #0070c0; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; }
        .connection-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .connection-line { stroke: #333; stroke-width: 2; fill: none; }
        .connection-label { position: absolute; background: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; color: #333; border: 1px solid #ccc; z-index: 6; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .error-message { background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white; padding: 20px; border-radius: 8px; text-align: center; font-weight: bold; margin: 20px 0; }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-content { flex-direction: column; }
            .input-panel { flex: none; }
            .output-panel { min-width: auto; }
            .container { min-width: 800px; }
        }
        
        @media (max-width: 768px) {
            body { padding: 10px; }
            .container { min-width: 600px; width: 98%; }
            .input-panel { padding: 20px; }
            .output-panel { padding: 20px; }
            .header h1 { font-size: 2em; }
            .btn { padding: 10px 16px; font-size: 14px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Activity Diagram Generator v5</h1>
            <p>Create beautiful activity diagrams with swimlanes - Fixed connections!</p>
        </div>

        <div class="main-content">
            <div class="input-panel">
                <h3 style="margin-bottom: 20px; color: #333;">Input Syntax</h3>
                <textarea id="syntax-input"></textarea>
                <div class="button-group">
                    <button class="btn btn-primary" id="generate-btn"><span>üîÑ</span> Generate Diagram</button>
                    <button class="btn btn-success" id="export-btn"><span>üì∑</span> Export Image</button>
                    <button class="btn btn-secondary" id="clear-btn"><span>üóëÔ∏è</span> Clear</button>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
                    <h4 style="margin-bottom: 10px; color: #1976d2;">Examples</h4>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn" style="background: #2196f3; color: white; padding: 8px 16px; font-size: 14px;" onclick="loadSimpleExample()">Simple</button>
                        <button class="btn" style="background: #4caf50; color: white; padding: 8px 16px; font-size: 14px;" onclick="loadLoginExample()">Login</button>
                        <button class="btn" style="background: #ff9800; color: white; padding: 8px 16px; font-size: 14px;" onclick="loadOrderExample()">Order</button>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                        <button class="btn" style="background: #009688; color: white; padding: 8px 16px; font-size: 14px;" onclick="loadSoftwareExample()">Software Dev</button>
                        <button class="btn" style="background: #9c27b0; color: white; padding: 8px 16px; font-size: 14px;" onclick="loadBankingExample()">Banking</button>
                        <button class="btn" style="background: #607d8b; color: white; padding: 8px 16px; font-size: 14px;" onclick="loadHospitalExample()">Hospital</button>
                    </div>
                </div>

                <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin-bottom: 15px; color: #333;">Syntax Guide</h4>
                    <div style="font-size: 14px; line-height: 1.6;">
                        <p><strong>Wrapper:</strong> <code>'Diagram Title' { ... }</code></p>
                        <p><strong>Swimlanes:</strong> <code>|Lane1, Lane2| { ... }</code></p>
                        <p><strong>Start:</strong> <code>$LaneName$</code></p>
                        <p><strong>End:</strong> <code>@LaneName@</code></p>
                        <p><strong>Activity:</strong> <code>(Lane) Activity Name;</code></p>
                        <p><strong>Data:</strong> <code>[Lane] Data Name;</code></p>
                        <p><strong>Decision:</strong> <code>&lt;Lane&gt; Question? { ... }</code></p>
                        <p><strong>Branches:</strong> <code>-Yes- { ... }</code> or <code>-No- { ... }</code></p>
                        <p><strong>Merge:</strong> <code>&gt;Lane&lt;;</code></p>
                    </div>
                </div>
            </div>

            <div class="output-panel">
                <h3 style="margin-bottom: 20px; color: #333;">Generated Diagram</h3>
                <div id="diagram-status" style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 12px; color: #666; display: none;">
                    <strong>Diagram Info:</strong> <span id="diagram-dimensions"></span> | <strong>Container:</strong> <span id="container-size"></span>
                </div>
                <div id="diagram-output" class="diagram-container"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        let editor, currentDiagram, textMeasureEl;
        const CONFIG = {
            HEADER_HEIGHT: 60, SWIMLANE_PADDING: 40, NODE_V_SPACING: 120,
            NODE_H_SPACING: 80, START_END_SIZE: 40, DECISION_SIZE: 100,
            MERGE_SIZE: 30, NODE_PADDING: { x: 20, y: 15 }, FONT_SIZE: 14,
            FONT_FAMILY: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
            MAX_NODE_WIDTH: 280, MIN_NODE_WIDTH: 100, CONNECTOR_V_MARGIN: 5,
        };

        window.pendingDiagram = null;
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'setDiagram') {
                if (window.editor) {
                    window.editor.setValue(event.data.payload);
                } else {
                    window.pendingDiagram = event.data.payload;
                }
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            if (window.pendingDiagram && window.editor) {
                window.editor.setValue(window.pendingDiagram);
                window.pendingDiagram = null;
            }
            
            textMeasureEl = document.createElement('span');
            Object.assign(textMeasureEl.style, { 
                visibility: 'hidden', position: 'absolute', whiteSpace: 'pre', 
                fontSize: `${CONFIG.FONT_SIZE}px`, fontWeight: '500', 
                fontFamily: CONFIG.FONT_FAMILY 
            });
            document.body.appendChild(textMeasureEl);
            
            editor = CodeMirror.fromTextArea(document.getElementById('syntax-input'), { 
                lineNumbers: true, theme: 'dracula', matchBrackets: true, 
                mode: 'text', lineWrapping: true 
            });
            
            document.getElementById('generate-btn').addEventListener('click', generateDiagram);
            document.getElementById('export-btn').addEventListener('click', exportDiagram);
            document.getElementById('clear-btn').addEventListener('click', () => { 
                editor.setValue(''); 
                document.getElementById('diagram-output').innerHTML = ''; 
                currentDiagram = null;
                const container = document.querySelector('.container');
                container.style.width = '';
                container.style.maxWidth = '';
                document.getElementById('diagram-status').style.display = 'none';
            });
            
            window.addEventListener('resize', () => {
                if (currentDiagram) {
                    setTimeout(generateDiagram, 100);
                }
            });
            
            loadSoftwareExample();
        });

        // Phase 1: Structure Analysis Functions
        function analyzeCompleteStructure(ast) {
            const nodeMap = new Map();
            const decisions = [];

            function traverseNodes(nodes, parentDecision = null, parentBranch = null) {
                nodes.forEach(node => {
                    node.parentDecision = parentDecision;
                    node.parentBranch = parentBranch;
                    nodeMap.set(node.id, node);

                    if (node.type === 'decision') {
                        decisions.push(node);
                        node.branches.forEach(branch => {
                            traverseNodes(branch.nodes, node, branch);
                        });
                    }
                });
            }

            traverseNodes(ast);
            return { 
                nodeMap, 
                decisions, 
                allNodes: Array.from(nodeMap.values()) 
            };
        }

        // Moved this function to be a standalone helper
        function calculateDecisionWidth(decision, analysis) {
            const subInfo = analyzeDecisionSubdivision(decision, analysis);
            if (!subInfo || subInfo.branches.length < 2) return 1;

            let totalWidth = 0;
            subInfo.branches.forEach(branchInfo => {
                const branch = decision.branches.find(b => b.label === branchInfo.label);
                const nestedDecisions = branch.nodes.filter(n => n.type === 'decision' && n.lane === decision.lane);
                
                let widthOfBranch = 1;
                if (nestedDecisions.length > 0) {
                    widthOfBranch = nestedDecisions
                        .map(d => calculateDecisionWidth(d, analysis))
                        .reduce((sum, width) => sum + width, 0);
                }
                totalWidth += widthOfBranch;
            });
            return totalWidth;
        }
        
        function planSwimlaneSubdivisions(analysis, originalSwimlanes) {
            const plan = new Map(); // Map<laneName, { maxSublanes: number }>

            const decisionsInLanes = new Map();
            analysis.decisions.forEach(d => {
                if (!decisionsInLanes.has(d.lane)) decisionsInLanes.set(d.lane, []);
                decisionsInLanes.get(d.lane).push(d);
            });

            // Phase-1: same-lane subdivision (existing logic)
            for (const [laneName, decisions] of decisionsInLanes.entries()) {
                const topLevelDecisions = decisions.filter(d => !d.parentDecision || d.parentDecision.lane !== laneName);
                
                let maxSublanes = 1;
                if(topLevelDecisions.length > 0){
                    maxSublanes = topLevelDecisions
                        .map(d => calculateDecisionWidth(d, analysis))
                        .reduce((sum, width) => sum + width, 0);
                }
                
                // If there are non-top-level decisions but no top-level ones that subdivide
                if (maxSublanes <= 1 && decisions.length > 0) {
                    const hasAnySubdivision = decisions.some(d => analyzeDecisionSubdivision(d, analysis));
                    if(hasAnySubdivision && maxSublanes < 2){
                        // A rough calculation for complex nested cases not originating from a clean top-level decision
                        maxSublanes = 1;
                        decisions.forEach(d => {
                            const s = analyzeDecisionSubdivision(d, analysis);
                            if(s) maxSublanes += s.subdivisionCount -1;
                        });
                    }
                }
                
                if (maxSublanes > 1) {
                    plan.set(laneName, { maxSublanes });
                    console.log(`Planning for lane "${laneName}": maxSublanes = ${maxSublanes}`);
                }
            }

            // Phase-2: cross-lane branches ‚Äì ensure target lanes have at least 2 sub-lanes
            const crossLaneExtra = new Map(); // Map<laneName, neededExtra>

            // Cross-lane branches that go BACKWARD (target lane is to the left of decision lane)
            analysis.decisions.forEach(dec => {
                const decIndex = originalSwimlanes.indexOf(dec.lane);
                if (decIndex === -1) return;
                dec.branches.forEach(br => {
                    if (br.nodes.length === 0) return;
                    const firstLane = br.nodes[0].lane;
                    const targetIndex = originalSwimlanes.indexOf(firstLane);
                    if (firstLane && firstLane !== dec.lane && targetIndex !== -1 && targetIndex < decIndex) {
                        // backward flow ‚Äì need room on target lane
                        crossLaneExtra.set(firstLane, (crossLaneExtra.get(firstLane) || 0) + 1);
                    }
                });
            });

            for (const [laneName, extra] of crossLaneExtra.entries()) {
                const current = plan.get(laneName)?.maxSublanes || 1;
                const needed = Math.max(2, current, extra + 1); // at least 2 lanes if any cross-lane branch
                if (needed > current) {
                    plan.set(laneName, { maxSublanes: needed });
                    console.log(`Cross-lane adjustment ‚Üí lane "${laneName}" now needs ${needed} sub-lanes`);
                }
            }
            return plan;
        }
        
        function analyzeDecisionSubdivision(decision, analysis) {
            const branchesStartingInSameLane = [];
            
            // Collect diagnostic information for each branch (first node lane & whether any node matches decision lane)
            console.log(`Analyzing decision "${decision.label}" in lane "${decision.lane}" for subdivision analysis:`, {
                totalBranches: decision.branches.length,
                branches: decision.branches.map(b => {
                    const firstLane = b.nodes.length > 0 ? b.nodes[0].lane : 'N/A';
                    const hasSameLane = b.nodes.some(n => n.lane === decision.lane);
                    return {
                        label: b.label,
                        nodeCount: b.nodes.length,
                        firstNodeLane: firstLane,
                        hasNodeInDecisionLane: hasSameLane
                    };
                })
            });
            
            // Consider a branch relevant for subdivision if it contains ANY node that resides in the same lane as the decision.
            decision.branches.forEach(branch => {
                const containsSameLaneNode = branch.nodes.some(n => n.lane === decision.lane);
                if (containsSameLaneNode) {
                    branchesStartingInSameLane.push({
                        label: branch.label,
                        nodes: branch.nodes
                    });
                }
            });
            
            console.log(`Branches starting in same lane: ${branchesStartingInSameLane.length}`);
            
            if (branchesStartingInSameLane.length >= 2) {
                const result = {
                    decisionId: decision.id,
                    lane: decision.lane,
                    branches: branchesStartingInSameLane,
                    subdivisionCount: branchesStartingInSameLane.length
                };
                console.log(`Decision "${decision.label}" requires subdivision:`, result);
                return result;
            }
            
            console.log(`Decision "${decision.label}" does not require subdivision.`);
            return null;
        }
        
        function applySubdivisionPlan(originalSwimlanes, subdivisionPlan) {
            const technicalSwimlanes = [];  // For internal layout logic
            const visualSwimlanes = [];     // For visual rendering
            let currentX = 0;
            const baseLaneWidth = 300;
            
            originalSwimlanes.forEach((laneName, originalIndex) => {
                const lanePlan = subdivisionPlan.get(laneName);
                const maxSubdivisionCount = lanePlan ? lanePlan.maxSublanes : 1;
                
                const totalLaneWidth = baseLaneWidth * maxSubdivisionCount;
                
                if (maxSubdivisionCount > 1) {
                    const subLaneWidth = totalLaneWidth / maxSubdivisionCount;
                    
                    for (let i = 0; i < maxSubdivisionCount; i++) {
                        const subdivisionLane = {
                            id: `${laneName}-${i + 1}`,
                            originalId: laneName,
                            width: subLaneWidth,
                            x: currentX + (i * subLaneWidth),
                            subdivisionLevel: 1, // This can be enhanced later for visual styling
                            subdivisionIndex: i,
                            isSubdivision: true,
                            isTechnical: true
                        };
                        technicalSwimlanes.push(subdivisionLane);
                        console.log(`Created technical subdivision:`, subdivisionLane);
                    }
                } else {
                    technicalSwimlanes.push({
                        id: laneName,
                        originalId: laneName,
                        width: totalLaneWidth,
                        x: currentX,
                        subdivisionLevel: 0,
                        subdivisionIndex: 0,
                        isSubdivision: false,
                        isTechnical: true
                    });
                }
                
                visualSwimlanes.push({
                    id: laneName,
                    originalId: laneName,
                    width: totalLaneWidth,
                    x: currentX,
                    subdivisionCount: maxSubdivisionCount
                });
                
                currentX += totalLaneWidth;
            });
            
            return {
                technical: technicalSwimlanes,
                visual: visualSwimlanes
            };
        }
        
        function getTargetLane(node, parentContext, laneData) {
            // Priority 1: If we're in a branch context, use its available sublanes
            if (parentContext && parentContext.availableSublanes && parentContext.availableSublanes.length > 0 && node.lane === parentContext.decisionLane) {
                const targetSublane = parentContext.availableSublanes[0]; // Use first available
                console.log(`Node "${node.label}" in branch "${parentContext.branchLabel}" ‚Üí subdivision "${targetSublane.id}"`);
                return targetSublane;
            }
            
            // Priority 1b: Cross-lane branch (node.lane ‚â† decisionLane): choose RIGHT-most sublane if available
            if (parentContext && parentContext.decisionLane && node.lane !== parentContext.decisionLane) {
                const allSubs = Array.from(laneData.values()).filter(l => l.isSubdivision && l.originalId === node.lane);
                if (allSubs.length > 0) {
                    const rightMost = allSubs.reduce((max, curr) => (curr.x > max.x ? curr : max), allSubs[0]);
                    console.log(`Cross-lane node "${node.label}" ‚Üí rightmost subdivision "${rightMost.id}"`);
                    return rightMost;
                }
            }
            
            // Priority 2: Try to find exact lane match (for non-subdivided lanes)
            let targetLane = laneData.get(node.lane);
            if (targetLane && !targetLane.isSubdivision) {
                return targetLane;
            }
            
            // Priority 3: Fallback to first subdivision of the original lane
            for (const [laneId, laneInfo] of laneData.entries()) {
                if (laneInfo.originalId === node.lane) {
                    console.log(`Node "${node.label}" fallback ‚Üí lane "${laneId}"`);
                    return laneInfo;
                }
            }
            
            return null;
        }
        
        function createSubdivisionMapping(decisionNode, availableSublanes, analysis) {
            const mapping = new Map();
            const subInfo = analyzeDecisionSubdivision(decisionNode, analysis);
            if (!subInfo) return mapping;

            // Determine ordering: if binary Yes/No style, place negative branch first (left)
            let orderedBranches = subInfo.branches;
            if (subInfo.branches.length === 2) {
                const lowerLabels = subInfo.branches.map(b => b.label.toLowerCase());
                if (lowerLabels.includes('yes') && lowerLabels.includes('no')) {
                    orderedBranches = subInfo.branches.sort((a, b) => {
                        return a.label.toLowerCase() === 'no' ? -1 : 1;
                    });
                } else if (lowerLabels.includes('true') && lowerLabels.includes('false')) {
                    orderedBranches = subInfo.branches.sort((a, b) => {
                        return a.label.toLowerCase() === 'false' ? -1 : 1;
                    });
                }
            }

            let sublaneCursor = 0;
            orderedBranches.forEach(branchInfo => {
                const branch = decisionNode.branches.find(b => b.label === branchInfo.label);
                const nestedDecisions = branch.nodes.filter(n => n.type === 'decision' && n.lane === decisionNode.lane);
                
                let widthOfBranch = 1;
                if (nestedDecisions.length > 0) {
                    widthOfBranch = nestedDecisions
                        .map(d => calculateDecisionWidth(d, analysis))
                        .reduce((sum, width) => sum + width, 0);
                }

                const assignedSublanes = availableSublanes.slice(sublaneCursor, sublaneCursor + widthOfBranch);
                mapping.set(branch.label, assignedSublanes);
                console.log(`Branch "${branch.label}" gets ${widthOfBranch} sublanes:`, assignedSublanes.map(l => l.id));
                sublaneCursor += widthOfBranch;
            });
            
            return mapping;
        }

        // V5 Parser - Clean and simple
        function parseToAST(text) {
            // --- New pre-processing: strip block comments & optional version header
            text = text.replace(/\/\*[\s\S]*?\*\//g, '').trim(); // remove /* ... */
            if (text.startsWith('@v=')) {
                const newlineIdx = text.indexOf('\n');
                text = newlineIdx !== -1 ? text.substring(newlineIdx + 1).trim() : '';
            }

            function getContentOfOuterBlock(str, openChar = '{', closeChar = '}') {
                const firstBrace = str.indexOf(openChar);
                if (firstBrace === -1) return null;
                let balance = 1;
                for (let i = firstBrace + 1; i < str.length; i++) {
                    if (str[i] === openChar) balance++;
                    else if (str[i] === closeChar) balance--;
                    if (balance === 0) return str.substring(firstBrace + 1, i).trim();
                }
                return null;
            }

            text = text.trim();
            const titleMatch = text.match(/^'([^']*)'/);
            if (!titleMatch) throw new Error("Diagram must be wrapped in 'Title' { ... }");
            const title = titleMatch[1];
            
            let diagramBody = getContentOfOuterBlock(text.substring(titleMatch[0].length).trim());
            if (diagramBody === null) throw new Error("Unmatched '{' or '}' for diagram title block.");

            const swimlaneMatch = diagramBody.match(/^\|([^|]*)\|/);
            if(!swimlaneMatch) throw new Error("Swimlanes must be defined with |Lane1, Lane2| { ... }");
            const rawLanes = swimlaneMatch[1].split(',').map(s => s.trim()).filter(Boolean);
            const aliasMap = new Map();
            const swimlanes = [];
            rawLanes.forEach(l => {
                if (l.includes('=')) {
                    const [alias, real] = l.split('=').map(s => s.trim());
                    if(alias) aliasMap.set(alias, real || alias);
                    swimlanes.push(real || alias);
                } else {
                    swimlanes.push(l);
                }
            });
            // remove duplicate lane names while keeping order
            const uniqueSwimlanes = [...new Set(swimlanes)];

            function translateLane(name){ return aliasMap.get(name) || name; }

            let mainContent = getContentOfOuterBlock(diagramBody.substring(swimlaneMatch[0].length).trim());
            if (mainContent === null) throw new Error("Unmatched '{' or '}' for swimlane block.");
            
            // remove line comments and trim
            const lines = mainContent.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('//'));
            
            let i = 0;
            function buildBlock(depth = 0) {
                const block = [];
                console.log(`[d${depth}] buildBlock started at line ${i}: "${lines[i]}"`);

                while (i < lines.length) {
                    const line = lines[i];
                    console.log(`[d${depth}] Processing line ${i}: "${line}"`);

                    if (line.match(/^-(.*?)-\s*\{$/)) {
                        console.log(`[d${depth}] Block end condition met (next branch). Breaking.`);
                        break;
                    }
                    if (line.trim() === '}') {
                        const nextLine = lines[i + 1] || '';
                        if (nextLine.trim() === '' || nextLine.trim() === '}' || nextLine.match(/^-(.*?)-\s*\{$/)) {
                            console.log(`[d${depth}] Block end condition met (closing brace). Breaking.`);
                            break;
                        } else {
                            console.log(`[d${depth}] Ignoring brace inside nested structure.`);
                            i++; // Skip this brace and continue within the current block
                            continue;
                        }
                    }
                    
                    i++;
                    const node = { id: `node_${Math.random().toString(36).substr(2, 9)}` };

                    const decisionMatch = line.match(/^<(.*?)>\s*(.*?)\s*\{$/);
                    if (decisionMatch) {
                        Object.assign(node, { type: 'decision', lane: translateLane(decisionMatch[1].trim()), label: decisionMatch[2].trim(), branches: [] });
                        console.log(`[d${depth}] Found decision "${node.label}". Looking for branches...`);
                        
                        while (i < lines.length && lines[i].match(/^-(.*?)-\s*\{$/)) {
                            const branchLine = lines[i];
                            const branchLabelMatch = branchLine.match(/^-(.*?)-\s*\{$/);
                            const branchLabel = branchLabelMatch[1].trim();
                            console.log(`[d${depth}] Found branch "${branchLabel}" at line ${i}.`);
                            i++; // Consume branch opening
                            node.branches.push({ id: `branch_${Math.random().toString(36).substr(2, 9)}`, label: branchLabel, nodes: buildBlock(depth + 1) });
                            if (i < lines.length && lines[i] === '}') { i++; }
                        }
                        console.log(`[d${depth}] Finished parsing branches for "${node.label}". Next line is ${i}: "${lines[i]}"`);
                    } else if (line.match(/^\$.*\$$/)) Object.assign(node, { type: 'start', lane: translateLane(line.match(/^\$(.*)\$$/)[1].trim()) });
                    else if (line.match(/^@.*@$/)) Object.assign(node, { type: 'end', lane: translateLane(line.match(/^@(.*)@$/)[1].trim()) });
                    else if (line.match(/^\(.*\).*;$/)) Object.assign(node, { type: 'activity', lane: translateLane(line.match(/^\((.*?)\)\s*(.*?);$/)[1].trim()), label: line.match(/^\((.*?)\)\s*(.*?);$/)[2].trim() });
                    else if (line.match(/^\[.*\].*;$/)) Object.assign(node, { type: 'datastore', lane: translateLane(line.match(/^\[(.*?)\]\s*(.*?);$/)[1].trim()), label: line.match(/^\[(.*?)\]\s*(.*?);$/)[2].trim() });
                    else if (line.match(/^>.*?<;$/)) Object.assign(node, { type: 'merge', lane: translateLane(line.match(/^>(.*?)<;/)[1].trim()), label: '' });
                    else continue;
                    
                    block.push(node);
                }
                console.log(`[d${depth}] buildBlock finished at line ${i}. Returning block with ${block.length} nodes.`);
                return block;
            }
            return { title, swimlanes: uniqueSwimlanes, ast: buildBlock() };
        }

        // V5 Layout Engine - With Smart Subdivision
        function calculateLayout(data) {
            const { ast, swimlanes, title } = data;
            const measureText = text => { 
                textMeasureEl.textContent = text || ''; 
                return { 
                    width: Math.min(CONFIG.MAX_NODE_WIDTH, Math.max(CONFIG.MIN_NODE_WIDTH, textMeasureEl.offsetWidth + CONFIG.NODE_PADDING.x * 2)), 
                    height: textMeasureEl.offsetHeight + CONFIG.NODE_PADDING.y * 2 
                }; 
            };
            
            // Phase 1: Pre-Analysis
            const structureAnalysis = analyzeCompleteStructure(ast);
            console.log(`Structure analysis complete:`, {
                decisions: structureAnalysis.decisions.map(d => ({id: d.id, label: d.label, lane: d.lane})),
                allNodes: structureAnalysis.allNodes.length
            });
            
            const subdivisionPlan = planSwimlaneSubdivisions(structureAnalysis, swimlanes);
            console.log(`Subdivision plan:`, Array.from(subdivisionPlan.entries()));
            
            // Create enhanced lane data with subdivisions
            const allNodes = new Map();
            const allConnections = [];
            const swimlaneStructure = applySubdivisionPlan(swimlanes, subdivisionPlan);
            const technicalLanes = swimlaneStructure.technical;
            const visualLanes = swimlaneStructure.visual;
            const laneData = new Map();
            
                                // Use technical lanes for node placement logic
            technicalLanes.forEach((lane, i) => {
                laneData.set(lane.id, { 
                    id: lane.id,
                    index: i, 
                    width: lane.width, 
                    x: lane.x,
                    originalId: lane.originalId || lane.id,
                    subdivisionLevel: lane.subdivisionLevel || 0,
                    isSubdivision: lane.isSubdivision || false,
                    subdivisionIndex: lane.subdivisionIndex || 0
                });
                console.log(`Registered lane "${lane.id}":`, laneData.get(lane.id));
            });

            function layoutBlock(nodes, startY, predecessors, parentContext = null, analysis) {
                let currentY = startY;
                let lastNodeIds = predecessors;
                
                // Determine the available sublanes for this block
                let availableSublanes;
                if (parentContext && parentContext.availableSublanes && parentContext.availableSublanes.length > 0 && parentContext.decisionLane === (nodes[0]?.parentDecision ? nodes[0].parentDecision.lane : parentContext.decisionLane)) {
                    // use parent sublanes only if node lane matches decision lane that created them
                    availableSublanes = parentContext.availableSublanes;
                } else {
                    // otherwise fetch all subdivisions that belong to the current node lane
                    availableSublanes = Array.from(laneData.values()).filter(l => l.isSubdivision && l.originalId === (nodes[0]?.lane || ''));
                }

                for (const node of nodes) {
                    allNodes.set(node.id, node);
                    
                    // Smart lane assignment for subdivided lanes
                    const targetLane = getTargetLane(node, parentContext, laneData);
                    if (!targetLane) throw new Error(`Swimlane for "${node.lane}" not found.`);
                    
                    node.x = targetLane.x + targetLane.width / 2;
                    // Merge node horizontal position will be refined later after we know predecessor lanes.
                    node.assignedLane = targetLane.id; // Track which subdivision was used
                    Object.assign(node, node.type.match(/start|end/) ? 
                        {width: CONFIG.START_END_SIZE, height: CONFIG.START_END_SIZE} : 
                        node.type === 'decision' ? 
                        {width: CONFIG.DECISION_SIZE, height: CONFIG.DECISION_SIZE} : 
                        node.type === 'merge' ? 
                        {width: CONFIG.MERGE_SIZE, height: CONFIG.MERGE_SIZE} : 
                        measureText(node.label)
                    );
                    
                    node.y = currentY + node.height / 2;

                    // Determine predecessor nodes for context-aware merge placement
                    const predecessorNodes = lastNodeIds.map(pred => allNodes.get(pred.id)).filter(Boolean);

                    // For merge nodes, decide X position based on predecessor lanes
                    if (node.type === 'merge') {
                        const predLaneIds = predecessorNodes.map(p => p && (p.assignedLane || p.lane)).filter(Boolean);
                        const distinctPredLanes = new Set(predLaneIds);

                        if (distinctPredLanes.size > 1) {
                            const predLaneInfos = Array.from(distinctPredLanes).map(id => laneData.get(id)).filter(Boolean);
                            const originalLanePreds = predLaneInfos.filter(info => info && info.originalId === node.lane);

                            if (originalLanePreds.length > 0) {
                                // Prefer aligning with predecessor that shares merge's original lane
                                const chosen = originalLanePreds.reduce((min, curr) => curr.x < min.x ? curr : min, originalLanePreds[0]);
                                node.x = chosen.x + chosen.width / 2;
                            } else {
                                // Otherwise use previous logic: if all from same lane, leftmost; else center
                                const distinctOriginals = new Set(predLaneInfos.map(info => info.originalId || info.id));
                                if (distinctOriginals.size === 1) {
                                    const leftmost = predLaneInfos.reduce((min, curr) => curr.x < min.x ? curr : min, predLaneInfos[0]);
                                    node.x = leftmost.x + leftmost.width / 2;
                                } else {
                                    const originalLaneVisual = visualLanes.find(l => l.id === node.lane);
                                    if (originalLaneVisual) {
                                        node.x = originalLaneVisual.x + originalLaneVisual.width / 2;
                                    }
                                }
                            }
                        }
                        // Jika hanya satu sub-lane, biarkan posisi apa adanya
                    }

                    // Connect from previous nodes
                    lastNodeIds.forEach(pred => {
                        allConnections.push({ from: pred.id, to: node.id, label: pred.label });
                    });

                    currentY += node.height + CONFIG.NODE_V_SPACING;
                    
                    if (node.type === 'decision') {
                        const branchStartY = currentY;
                        const branchExitPoints = [];
                        let maxBranchHeight = 0;

                        // Refresh sublane list for this decision's own lane, but only those at/after current sublane index
                        let decisionLaneSublanes = Array.from(laneData.values())
                              .filter(l => l.isSubdivision && l.originalId === node.lane)
                              .sort((a,b) => a.x - b.x);

                        const currentSubIndex = decisionLaneSublanes.findIndex(l => l.id === node.assignedLane);
                        if (currentSubIndex >= 0) {
                            decisionLaneSublanes = decisionLaneSublanes.slice(currentSubIndex);
                        }

                        const decisionMapping = createSubdivisionMapping(
                              node,
                              decisionLaneSublanes,
                              analysis);

                        node.branches.forEach((branch, branchIndex) => {
                            const inheritedSublanes = decisionMapping.get(branch.label) && decisionMapping.get(branch.label).length > 0
                                ? decisionMapping.get(branch.label)
                                : (parentContext && parentContext.availableSublanes ? parentContext.availableSublanes : []);

                            const branchContext = {
                                decisionId: node.id,
                                decisionLane: node.lane,
                                branchLabel: branch.label,
                                branchIndex: branchIndex,
                                availableSublanes: inheritedSublanes
                            };
                            
                            const layout = layoutBlock(branch.nodes, branchStartY, [{ id: node.id, label: branch.label }], branchContext, analysis);
                            branchExitPoints.push(...layout.exitPoints);
                            maxBranchHeight = Math.max(maxBranchHeight, layout.height);
                        });
                        
                        currentY += maxBranchHeight;
                        lastNodeIds = branchExitPoints;
                    } else {
                        lastNodeIds = [{ id: node.id }];
                    }
                }
                return { height: currentY - startY, exitPoints: lastNodeIds };
            }
            
            // Pass the complete analysis object into the layout engine
            layoutBlock(ast, CONFIG.HEADER_HEIGHT, [], null, structureAnalysis);

            // Connection improvements - ensure all nodes are connected
            const allNodesArray = Array.from(allNodes.values());
            
            // Find disconnected nodes (nodes with no incoming connections except start nodes)
            allNodesArray.forEach(node => {
                if (node.type !== 'start' && node.type !== 'merge' && node.type !== 'decision' && node.type !== 'end') {
                    const hasIncoming = allConnections.some(conn => conn.to === node.id);
                    if (!hasIncoming) {
                        // Find the nearest node above this one
                        const nodesAbove = allNodesArray.filter(n => n.y < node.y);
                        if (nodesAbove.length > 0) {
                            const nearest = nodesAbove.reduce((prev, curr) => 
                                Math.abs(curr.y - node.y) < Math.abs(prev.y - node.y) ? curr : prev
                            );
                            allConnections.push({ from: nearest.id, to: node.id });
                        }
                    }
                }
            });

            const finalHeight = Math.max(600, Math.max(...allNodesArray.map(n => n.y)) + 200);
            const totalWidth = visualLanes.reduce((total, lane) => Math.max(total, lane.x + lane.width), 0);
            
            return { 
                nodes: allNodesArray, 
                connections: allConnections, 
                lanes: visualLanes,  // Use visual lanes for rendering
                technicalLanes: Array.from(laneData.values()), // Keep technical for debugging
                width: totalWidth, 
                height: finalHeight, 
                title, 
                swimlanes: visualLanes,
                originalSwimlanes: swimlanes 
            };
        }

        function generateDiagram() {
            const output = document.getElementById('diagram-output');
            const statusDiv = document.getElementById('diagram-status');
            const dimensionsSpan = document.getElementById('diagram-dimensions');
            const containerSpan = document.getElementById('container-size');
            
            try {
                const parsed = parseToAST(editor.getValue());
                const layout = calculateLayout(parsed);
                
                adjustContainerSize(layout.width);
                
                const container = document.querySelector('.container');
                const subdivisionInfo = layout.technicalLanes.filter(lane => lane.isSubdivision).length > 0 
                    ? ` [${layout.technicalLanes.filter(lane => lane.isSubdivision).length} subdivisions]` 
                    : '';
                dimensionsSpan.textContent = `${layout.width}px √ó ${layout.height}px (${layout.swimlanes.length} lanes${subdivisionInfo})`;
                containerSpan.textContent = `${parseInt(container.style.width || container.offsetWidth)}px`;
                statusDiv.style.display = 'block';
                
                renderDiagram(layout, output);
            } catch (error) {
                statusDiv.style.display = 'none';
                output.innerHTML = `<div class="error-message">‚ùå Error: ${error.message}</div>`;
                console.error(error);
            }
        }
        
        function renderDiagram(layout, container) {
            container.innerHTML = '';
            if(!layout.title || !layout.swimlanes) return;
            
            const titleDiv = Object.assign(document.createElement('div'), { 
                className: 'diagram-title', 
                textContent: layout.title 
            });
            
            const swimlanesContainer = Object.assign(document.createElement('div'), { 
                className: 'swimlanes-container' 
            });
            Object.assign(swimlanesContainer.style, { 
                width: `${layout.width}px`, 
                height: `${layout.height}px` 
            });
            
            container.append(titleDiv, swimlanesContainer);
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'connection-svg');
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `<marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto" fill="#333"><polygon points="0 0, 10 3.5, 0 7" /></marker>`;
            svg.appendChild(defs);
            swimlanesContainer.appendChild(svg);

            layout.lanes.forEach(lane => {
                const el = Object.assign(document.createElement('div'), { className: 'swimlane' });
                Object.assign(el.style, { left: `${lane.x}px`, width: `${lane.width}px` });
                
                // Always use original lane name for visual display
                const laneTitle = lane.originalId || lane.id;
                
                const titleEl = Object.assign(document.createElement('div'), { 
                    className: 'swimlane-title', 
                    textContent: laneTitle 
                });
                el.appendChild(titleEl);
                swimlanesContainer.appendChild(el);
                
                // Add invisible subdivision guidelines for subdivided lanes (optional debug)
                if (lane.subdivisionCount > 1) {
                    const subWidth = lane.width / lane.subdivisionCount;
                    for (let i = 1; i < lane.subdivisionCount; i++) {
                        const guideline = document.createElement('div');
                        Object.assign(guideline.style, {
                            position: 'absolute',
                            left: `${lane.x + (i * subWidth)}px`,
                            top: '0',
                            width: '1px',
                            height: '100%',
                            background: 'rgba(0,0,0,0.1)',
                            pointerEvents: 'none',
                            zIndex: '1'
                        });
                        swimlanesContainer.appendChild(guideline);
                    }
                }
            });
            
            layout.nodes.forEach(node => {
                if(node.x === undefined || node.y === undefined) return;
                const el = Object.assign(document.createElement('div'), { 
                    id: node.id, 
                    className: `node node-${node.type}` 
                });
                Object.assign(el.style, { 
                    left: `${node.x}px`, 
                    top: `${node.y}px`, 
                    width: `${node.width}px`, 
                    height: `${node.height}px` 
                });
                
                if (node.type === 'decision') {
                    el.style.transform = `translate(-50%, -50%) rotate(45deg)`;
                    el.innerHTML = `<div class="node-decision-text">${node.label}</div>`;
                } else {
                    el.style.transform = `translate(-50%, -50%)`;
                    el.textContent = node.label || '';
                }
                if (node.type === 'end') el.innerHTML = '';
                swimlanesContainer.appendChild(el);
            });

            layout.connections.forEach(conn => {
                const from = layout.nodes.find(n => n.id === conn.from);
                const to = layout.nodes.find(n => n.id === conn.to);
                if (!from || !to || from.x === undefined || to.x === undefined) return;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.setAttribute('class', 'connection-line');
                
                const fromY = from.y + from.height / 2;
                const toY = to.y - to.height / 2;

                let d = `M ${from.x} ${fromY} C ${from.x} ${fromY + 50}, ${to.x} ${toY - 50}, ${to.x} ${toY}`;
                
                path.setAttribute('d', d);
                svg.appendChild(path);

                if (conn.label) {
                    const label = Object.assign(document.createElement('div'), { className: 'connection-label', textContent: conn.label });
                    const labelX = from.x + (to.x - from.x) * 0.15;
                    const labelY = fromY + 25;
                    Object.assign(label.style, { left: `${labelX}px`, top: `${labelY}px`, transform: 'translateX(-50%)' });
                    swimlanesContainer.appendChild(label);
                }
            });
            
            currentDiagram = container;
        }
        
        async function exportDiagram() {
            const diagramContainer = document.getElementById('diagram-output');
            if (!currentDiagram || !diagramContainer.hasChildNodes()) {
                return alert('Please generate a diagram first');
            }
            
            const titleEl = diagramContainer.querySelector('.diagram-title');
            const swimlanesEl = diagramContainer.querySelector('.swimlanes-container');

            if (!titleEl || !swimlanesEl) return alert('Cannot find diagram elements to export.');
            
            try {
                const exportContainer = document.createElement('div');
                exportContainer.style.backgroundColor = '#ffffff';
                exportContainer.style.padding = '20px';
                exportContainer.style.width = `${swimlanesEl.offsetWidth + 40}px`;

                exportContainer.appendChild(titleEl.cloneNode(true));
                
                const canvas = await html2canvas(swimlanesEl, { 
                    backgroundColor: '#ffffff', 
                    scale: 1.5, 
                    useCORS: true 
                });
                exportContainer.appendChild(canvas);
                
                document.body.appendChild(exportContainer);
                
                const finalCanvas = await html2canvas(exportContainer, {
                    backgroundColor: '#ffffff'
                });

                const link = Object.assign(document.createElement('a'), {
                    download: `${(titleEl.textContent || 'activity-diagram').replace(/\s/g, '_')}.png`,
                    href: finalCanvas.toDataURL()
                });
                link.click();
                
                document.body.removeChild(exportContainer);

            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export diagram.');
            }
        }

        function loadSoftwareExample() {
            const example = `'Software Development Process' {
    |Product Owner, Developer, Tester, DevOps| {
        $Product Owner$
        (Product Owner) Define requirements;
        (Developer) Write code;
        <Developer> Code complete? {
            -Yes- {
                (Tester) Execute tests;
                <Tester> Tests passed? {
                    -Yes- {
                        (DevOps) Deploy to production;
                    }
                    -No- {
                        (Developer) Fix bugs;
                    }
                }
                >Tester<;
            }
            -No- {
                (Developer) Continue coding;
            }
        }
        >Developer<;
        @Product Owner@
    }
}`;
            editor.setValue(example);
        }

        function loadLoginExample() {
            const example = `'Login Process' {
    |User, System| {
        $User$
        (User) Enter credentials;
        (System) Validate credentials;
        <System> Valid credentials? {
            -Yes- {
                (System) Check account status;
                <System> Account active? {
                    -Yes- {
                        (System) Grant access;
                    }
                    -No- {
                        (System) Show inactive message;
                    }
                }
                >System<;
            }
            -No- {
                (System) Show error;
                (User) Try again;
            }
        }
        >System<;
        @User@
    }
}`;
            editor.setValue(example);
        }

        function loadOrderExample() {
            const example = `'Order Processing' {
    |Customer, System, Warehouse| {
        $Customer$
        (Customer) Place order;
        (System) Validate order;
        <System> Order valid? {
            -Yes- {
                (System) Process payment;
                <System> Payment success? {
                    -Yes- {
                        (Warehouse) Ship order;
                        (System) Confirm order;
                    }
                    -No- {
                        (System) Cancel order;
                    }
                }
                >System<;
            }
            -No- {
                (System) Cancel order;
                (System) Show error;
            }
        }
        >System<;
        @Customer@
    }
}`;
            editor.setValue(example);
        }
        
        function loadBankingExample() {
            const example = `'Online Banking Transfer' {
    |Customer, Bank System, Database| {
        $Customer$
        (Customer) Login to account;
        (Bank System) Validate credentials;
        <Bank System> Valid login? {
            -Yes- {
                (Customer) Enter transfer details;
                (Bank System) Validate transfer;
                <Bank System> Sufficient funds? {
                    -Yes- {
                        (Database) Update balances;
                        (Bank System) Send confirmation;
                    }
                    -No- {
                        (Bank System) Show insufficient funds error;
                    }
                }
                >Bank System<;
            }
            -No- {
                (Bank System) Show login error;
            }
        }
        >Bank System<;
        @Customer@
    }
}`;
            editor.setValue(example);
        }

        function loadHospitalExample() {
            const example = `'Patient Treatment Process' {
    |Patient, Nurse, Doctor, Lab| {
        $Patient$
        (Patient) Arrive at hospital;
        (Nurse) Register patient;
        (Doctor) Examine patient;
        <Doctor> Needs tests? {
            -Yes- {
                (Lab) Conduct tests;
                [Database] Store results;
                (Doctor) Review results;
                (Doctor) Prescribe medication;
            }
            -No- {
                (Doctor) Give basic advice;
            }
        }
        >Doctor<;
        @Patient@
    }
}`;
            editor.setValue(example);
        }

        function loadSimpleExample() {
            const example = `'Simple Process' {
    |User, System| {
        $User$
        (User) Start process;
        (System) Validate input;
        <System> Is valid? {
            -Yes- {
                (System) Process data;
                (System) Send confirmation;
            }
            -No- {
                (System) Show error;
            }
        }
        >System<;
        @User@
    }
}`;
            editor.setValue(example);
        }

        function adjustContainerSize(diagramWidth) {
            const container = document.querySelector('.container');
            const inputPanelWidth = 400;
            const padding = 60;
            const minContainerWidth = 1000;
            
            const requiredWidth = inputPanelWidth + diagramWidth + padding + 100;
            const finalWidth = Math.max(minContainerWidth, Math.min(requiredWidth, window.innerWidth * 0.95));
            
            container.style.width = `${finalWidth}px`;
            container.style.maxWidth = 'none';
        }
    </script>
</body>
</html> 